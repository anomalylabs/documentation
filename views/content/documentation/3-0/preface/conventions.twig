{#
title: Core Conventions
sections:
    - Structure
    - Transforming
    - Property Handlers
    - Property Evaluation
    - Property Normalization
#}

{% extends "fizl::layouts/documentation" %}

{% block content %}
    {% markdown %}
    The Coding Standards document describes the coding standards for the AnomalyLabs projects and first party addons and packages.
    This document describes coding standards and **conventions** used in the Streams Platform and first party addons and packages
    to make addon development more consistent, predictable and automatable.

    You are highly encouraged to follow them in your own code, but you do not have to.


    ## {{ html_anchor('structure', 'Structure') }}

    When building addons or packages that use the services in the Streams Platform package it is highly suggested to
    use a specific folder structure (and therefore namespace structure) in order to allow the Streams Platform to automate
    as much as possible for you by default.

    This is highly suggested but not required. You may use any class structure you wish and will only need to do a small amount
    of additional work (like defining your custom collection instead of relyng on class transformation).

    <script src="https://gist.github.com/RyanThompson/d82fe6e169dcf7c082ec.js"></script>


    ## {{ html_anchor('transforming', 'Transforming') }}

    Class sniffing or transforming is a practice used by core in where a base class like `FooModel` would transform to it's
    resolving counterpart like `FooCollection`. The resolving class may also work backwards like a table builder `Table\FooTableBuilder`
    looking for it's model counterpart `FooModel`.

    Class sniffing and transformation is used heavily in core and allows developers to simply create the counterpart classes
    and not worry about defining them in the calling classes.

    Class transformation is not required and is detected automatically. You may also define your resolving classes by
    overriding their resolving methods like this:

    <script src="https://gist.github.com/RyanThompson/266445d43824c77afeb2.js"></script>


    ## {{ html_anchor('property-handlers', 'Property Handlers') }}

    Property handlers are a form of transforming described above. Many properties in core services can be handled by a
    dedicated class. Property handlers are called from Laravel's IoC container. In most cases the object who's property is
    being handled will be passed to the handler as well as any other important arguments.

    Property handlers are not required and are detected automatically. You may also define your own handlers on the properties.

    <script src="https://gist.github.com/RyanThompson/102888a4b09f0aea95ba.js"></script>


    ## {{ html_anchor('property-evaluation', 'Property Evaluation') }}

    Property evaluation is a practice in which property values that are closures are called through the IoC container.
    In most cases the object who's property is being evaluated will be passed to the closure as well as any other important arguments.

    Property evaluation is not required and is detected automatically. Properties are evaluated recursively as needed which
    means that the whole property can be a closure or individual pieces of the property or both.

    Since you can not define a class property with a closure in it here is an example of using a property handler that sets
    the property using it's setter and includes a closure.

    <script src="https://gist.github.com/RyanThompson/d009c024853781f47c03.js"></script>


    ## {{ html_anchor('property-normalization', 'Property Normalization') }}

    Property normalization is a practice in which property values only require minimal input from the dev and are later
    normalized into full input.

    Property normalization is not required and is detected automatically. Normalization varies and will be documented when supported.

    Property normalization is sometimes determined by "registries". For example the button registry contains a set of pre-registered
    buttons that can be defined by a simple string like `delete` and then either used as is or overriden by passing additional
    properties.

    Below is an example of minimal input, partial overriding, and full definition of the same basic button.

    *Note that the icon property for the full definition is minimal input and will be later transformed as well.*

    <script src="https://gist.github.com/RyanThompson/1f71012ca664fbfb7fa5.js"></script>

    {% endmarkdown %}
{% endblock %}